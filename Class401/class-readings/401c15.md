# Class 15 Readings: Trees

## Trees

___  
[Access Link Here](https://codefellows.github.io/common_curriculum/data_structures_and_algorithms/Code_401/class-15/resources/Trees.html)  

### What's a Tree?  

**Binary Trees**, **Binary Search Trees**, and **K-ary Trees** are some more data structures consisting of `Nodes`.  

1. ***Root:***  Node at the beginning of the tree  
2. ***K:*** number of specifies max number of children any node may have (**k-ary tree**) 
3. ***Left:*** reference to one child node (**binary tree**)
4. ***Right:*** reference to other child node (**binary tree**)
5. ***Edge:*** link between parent and child node
6. ***Leaf:*** node that does NOT have children 
7. ***Height:*** number of edges from the root to furthest leaf

___

### Traversals:  

- **Depth First:**  

    - Prioritzes height of tree first

**FILO** (**F**irst **I**n **L**ast **O**ut): 1st item pushed in stack ill be last item popped out

OR

**LIFO** (**L**ast **I**n **F**irst **O**ut): last item pushed to stack will be 1st item popped out 

### Push 

When pushing in a new Node, must assign it as the `Top` and it's `Next` value the original Top

*Pseudocode:* 

```python 

ALGORITHM push(value)
//INPUT <-- value to add, wrapped in Node internally 
// OUPUT <-- none

node = new Node(value)
node.next <-- Top
top <-- Node

```  

### Pop  

Check `isEmpty` before popping 

*Pseudocode:*  

```python 

ALGORITHM pop()
//INPUT <-- No input 
//OUTPUT <-- value of top Node in stack 
//EXCEPTION if stack is empty

Node temp <-- top
top <-- top.next  
temp.next <-- null
return temp.value

```  

### Peek  

Check `isEmpty` before peeking

*Pseudocode:*  

```python 

ALGORITHM peek()
//INPUT <-- none
//OUTPUT <-- value of top Node in stack 
//EXCEPTION if stack is empty

return top.value

```  

### isEmpty  

*Pseudocode:*  

```python 

ALGORITHM peek()
//INPUT <-- none
//OUTPUT <-- boolean

return top = NULL

```  

___  

### What's a Queue?  

Data structure consisting of `Nodes`. 

**Metaphor: Line at the movie theatres*

1. ***Enqueue:***  Nodes/items that are added into the queue 
2. ***Dequeue:*** Node/items that are removed from queue  
3. ***Front:*** front/first Node of the queue
4. ***Rear:*** rear/last Node of the queue
5. ***Peek:*** lets you view the front Node of the queue
6. ***IsEmpty:*** returns true when queue is empty (otherwise false) 

**Will raise exceptions if stack is empty and try to use 2 and 5*â€º  

**FILO** (**F**irst **I**n **L**ast **O**ut): 1st item pushed in stack ill be last item popped out

OR

**LIFO** (**L**ast **I**n **F**irst **O**ut): last item pushed to stack will be 1st item popped out 

### Enqueue  

When adding in a new Node, must assign it as the `Rear` and it's `Next` value the original Rear

*Pseudocode:* 

```python 

ALGORITHM enqueue(value)
//INPUT <-- value to add, wrapped in Node internally 
// OUPUT <-- none

node = new Node(value)
rear.next <-- node
rear <-- node

```  

### Dequeue   

Check `isEmpty` before popping  

*Pseudocode:*  

```python 

ALGORITHM dequeue()
//INPUT <-- none
//OUTPUT <-- value of removed Node
//EXCEPTION if stack is empty

Node temp <-- front
front <-- front.next  
temp.next <-- null
return temp.value

```  

### Peek  

Check `isEmpty` before peeking

*Pseudocode:*  

```python 

ALGORITHM peek()
//INPUT <-- none
//OUTPUT <-- value of front Node in queue 
//EXCEPTION if stack is empty

return front.value

```  

### isEmpty  

*Pseudocode:*  

```python 

ALGORITHM peek()
//INPUT <-- none
//OUTPUT <-- boolean

return front = NULL

```  
